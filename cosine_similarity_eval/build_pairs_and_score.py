import argparse
import json
import csv
from pathlib import Path

from cosine_similarity_eval.metric_cosine import CosineSimilarityScorer


def load_json_or_jsonl(path: Path):
    """Load either a .json list or .jsonl (one JSON object per line)."""
    if path.suffix == ".jsonl":
        data = []
        with path.open("r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if line:
                    data.append(json.loads(line))
        return data
    else:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)


def load_human_annotations(human_path: str):
    """
    Load human (ground-truth) Bingo annotations.

    Your annotation.jsonl items look like either:
      {
        "path": "/t2i/cor/0.png",
        "question": "...",
        "ground truth": "..."
      }
    or:
      {
        "path": "/OCR/english/5_en.png",
        "question": "...."
        # no ground truth -> skip
      }

    We use:
      - path          -> image filename
      - ground truth  -> human annotation text (when present)
    """
    path = Path(human_path)
    data = load_json_or_jsonl(path)

    human_by_image = {}

    for item in data:
        # image filename (strip folder)
        image_id = (
            item.get("path")
            or item.get("image_id")
            or item.get("image")
        )

        # human text: prefer your "ground truth" field
        text = (
            item.get("ground truth")  # NOTE: key has a space
            or item.get("annotation")
            or item.get("caption")
            or item.get("answer")
        )

        # If we don't have either, skip this item
        if image_id is None or text is None:
            # Just ignore items without labels instead of crashing
            continue

        image_id = Path(image_id).name
        human_by_image[image_id] = text

    print(f"[human] Loaded {len(human_by_image)} labeled images.")
    return human_by_image




def load_gemini_annotations(gemini_path: str):
    """
    Load Gemini outputs generated by Sayan's pipeline.

    Tries several common key names for image id and text.
    """
    path = Path(gemini_path)
    data = load_json_or_jsonl(path)

    gemini_by_image = {}

    for item in data:
        image_id = (
            item.get("image_id")
            or item.get("image")
            or item.get("path")
        )

        text = (
            item.get("gemini_annotation")
            or item.get("response")
            or item.get("answer")
            or item.get("prediction")
            or item.get("model_output")
        )

        if image_id is None or text is None:
            raise ValueError(f"Could not find image_id/text in gemini item: {item}")

        image_id = Path(image_id).name
        gemini_by_image[image_id] = text

    return gemini_by_image



def build_pairs(human_by_image, gemini_by_image):
    """
    Join human + Gemini annotations on image_id.
    """
    image_ids = sorted(set(human_by_image.keys()) & set(gemini_by_image.keys()))
    pairs = []

    for img_id in image_ids:
        pairs.append(
            {
                "image_id": img_id,
                "human_annotation": human_by_image[img_id],
                "gemini_annotation": gemini_by_image[img_id],
            }
        )

    return pairs


def save_pairs_json(pairs, path: str):
    out = Path(path)
    out.parent.mkdir(parents=True, exist_ok=True)
    with out.open("w", encoding="utf-8") as f:
        json.dump(pairs, f, indent=2, ensure_ascii=False)


def save_scores_csv(pairs, scores, mean_score, std_score, path: str):
    out = Path(path)
    out.parent.mkdir(parents=True, exist_ok=True)

    with out.open("w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(
            ["image_id", "human_annotation", "gemini_annotation", "cosine_similarity"]
        )

        for pair, s in zip(pairs, scores):
            writer.writerow(
                [
                    pair["image_id"],
                    pair["human_annotation"],
                    pair["gemini_annotation"],
                    f"{s:.4f}",
                ]
            )

        writer.writerow([])
        writer.writerow(["mean", "", "", f"{mean_score:.4f}"])
        writer.writerow(["std", "", "", f"{std_score:.4f}"])


def main():
    parser = argparse.ArgumentParser(
        description="Build human+Gemini Bingo pairs and run cosine similarity."
    )
    parser.add_argument(
        "--human_path",
        required=True,
        help="Path to human annotation file (json or jsonl).",
    )
    parser.add_argument(
        "--gemini_path",
        required=True,
        help="Path to Gemini output file (json or jsonl).",
    )
    parser.add_argument(
        "--pairs_out",
        required=True,
        help="Where to save combined pairs JSON.",
    )
    parser.add_argument(
        "--scores_out",
        required=True,
        help="Where to save CSV of cosine scores.",
    )
    parser.add_argument(
        "--model_name",
        default="all-MiniLM-L6-v2",
        help="Sentence-Transformers model name for embeddings.",
    )

    args = parser.parse_args()

    # 1) Load annotations
    human_by_image = load_human_annotations(args.human_path)
    gemini_by_image = load_gemini_annotations(args.gemini_path)

    # 2) Build aligned pairs
    pairs = build_pairs(human_by_image, gemini_by_image)
    print(f"Built {len(pairs)} (human, Gemini) pairs.")

    if not pairs:
        print(
            "⚠️  No overlapping image_ids between human and Gemini annotations. "
            "Check that the keys and filenames line up."
        )
        save_pairs_json([], args.pairs_out)
        return

    save_pairs_json(pairs, args.pairs_out)

    # 3) Run cosine similarity scorer
    scorer = CosineSimilarityScorer(model_name=args.model_name)
    human_texts = [p["human_annotation"] for p in pairs]
    gemini_texts = [p["gemini_annotation"] for p in pairs]

    scores, mean_score, std_score = scorer.score_pairs(human_texts, gemini_texts)
    save_scores_csv(pairs, scores, mean_score, std_score, args.scores_out)

    # 4) Summary prints so you can see it worked
    print(f"✅ Wrote {len(scores)} scores to {args.scores_out}")
    print(f"   Mean cosine similarity: {mean_score:.4f}")
    print(f"   Std dev: {std_score:.4f}")
    print(f"   Pairs saved to:  {args.pairs_out}")


if __name__ == "__main__":
    main()
